import type { CalendarEvent } from '../../types/mcp-types.js';

export const timedEvent: CalendarEvent = {
  id: 'timed-event',
  summary: 'Timed Strategy Review',
  start: {
    dateTime: '2024-02-04T15:00:00.000Z'
  },
  end: {
    dateTime: '2024-02-04T16:00:00.000Z'
  },
  attendees: [
    { email: 'attendee@example.com', responseStatus: 'accepted' }
  ]
};

export const allDayEvent: CalendarEvent = {
  id: 'all-day-event',
  summary: 'Company Offsite',
  start: {
    date: '2024-02-03'
  },
  end: {
    date: '2024-02-04'
  },
  attendees: [
    { email: 'attendee@example.com', responseStatus: 'accepted' },
    { email: 'other@example.com', responseStatus: 'needsAction' }
  ]
};

export const outsideRangeEvent: CalendarEvent = {
  id: 'outside-range-event',
  summary: 'Planning Sync',
  start: {
    dateTime: '2024-03-01T17:00:00.000Z'
  },
  end: {
    dateTime: '2024-03-01T18:00:00.000Z'
  },
  attendees: [
    { email: 'attendee@example.com', responseStatus: 'accepted' }
  ]
};

export const mockCalendarEvents: CalendarEvent[] = [
  timedEvent,
  allDayEvent,
  outsideRangeEvent
];
server/mcp/tools/__tests__/calendar-tools.test.ts
New
+77
-0

import { beforeEach, afterEach, describe, expect, it, vi } from 'vitest';

const { googleCalendarModulePath } = vi.hoisted(() => ({
  googleCalendarModulePath: new URL('../../../services/googleCalendar.js', import.meta.url).href
}));

const getUpcomingEvents = vi.fn();
const getEventById = vi.fn();

vi.mock(googleCalendarModulePath, () => ({
  googleCalendarService: {
    getUpcomingEvents,
    getEventById
  }
}), { virtual: true });

import { calendarMeetingContext, calendarAttendeeHistory } from '../calendar-tools.js';
import type { MCPToolContext } from '../../types/mcp-types.js';
import { allDayEvent, mockCalendarEvents, timedEvent } from '../__fixtures__/calendar-events.js';

const baseContext: MCPToolContext = {
  userId: 'user-123',
  storage: {}
};

describe('calendarMeetingContext', () => {
  beforeEach(() => {
    getUpcomingEvents.mockReset();
    getEventById.mockReset();
  });

  it('includes all-day events when filtering by time range', async () => {
    getUpcomingEvents.mockResolvedValue(mockCalendarEvents);

    const result = await calendarMeetingContext({
      timeRange: {
        start: '2024-02-02T00:00:00.000Z',
        end: '2024-02-05T00:00:00.000Z'
      }
    }, baseContext);

    expect(getUpcomingEvents).toHaveBeenCalledWith('user-123', 100);
    expect(result.events.map(event => event.id)).toEqual([
      timedEvent.id,
      allDayEvent.id
    ]);
  });
});

describe('calendarAttendeeHistory', () => {
  beforeEach(() => {
    getUpcomingEvents.mockReset();
    getEventById.mockReset();
    vi.useFakeTimers();
    vi.setSystemTime(new Date('2024-02-05T12:00:00.000Z'));
  });

  afterEach(() => {
    vi.useRealTimers();
  });

  it('includes all-day events within the lookback window', async () => {
    getUpcomingEvents.mockResolvedValue(mockCalendarEvents);

    const result = await calendarAttendeeHistory({
      attendeeEmail: 'attendee@example.com',
      lookbackDays: 7,
      maxResults: 5
    }, baseContext);

    expect(getUpcomingEvents).toHaveBeenCalledWith('user-123', 200);
    expect(result.events.map(event => event.id)).toEqual([
      timedEvent.id,
      allDayEvent.id
    ]);
  });
});
server/mcp/tools/calendar-tools.ts
+22
-4

import {
  calendarMeetingContextSchema,
  calendarAttendeeHistorySchema,
  type CalendarEvent,
  type MCPToolContext
} from '../types/mcp-types.js';

function getEventStartInstant(event: { start?: { dateTime?: string; date?: string } }): Date | null {
  const startValue = event.start?.dateTime ?? event.start?.date;
  if (!startValue) {
    return null;
  }

  const startDate = new Date(startValue);
  if (Number.isNaN(startDate.getTime())) {
    return null;
  }

  if (event.start?.date && !event.start?.dateTime) {
    startDate.setHours(0, 0, 0, 0);
  }

  return startDate;
}

/**
 * Google Calendar Meeting Context Tool
 * Gets details about upcoming or recent meetings from Google Calendar
 */
export async function calendarMeetingContext(
  args: unknown, 
  context: MCPToolContext
): Promise<{ events: CalendarEvent[]; total: number }> {
  try {
    const params = calendarMeetingContextSchema.parse(args);
    
    // Import the Google Calendar service dynamically
    const { googleCalendarService } = await import('../../services/googleCalendar.js');
    
    let events: any[] = [];
    
    if (params.eventId) {
      // Get specific event by ID
      const event = await googleCalendarService.getEventById(context.userId, params.eventId);
      if (event) {
        events = [event];
      }
    } else if (params.contactEmail) {
      // Search for events with specific attendee
      const allEvents = await googleCalendarService.getUpcomingEvents(context.userId, 50);
      events = allEvents.filter(event => {
        if (!event.attendees) return false;
        return event.attendees.some((attendee: any) => 
          attendee.email === params.contactEmail
        );
      });
    } else if (params.timeRange) {
      // Get events in specific time range
      const startTime = new Date(params.timeRange.start);
      const endTime = new Date(params.timeRange.end);
      
      // Use the time range to filter events
      const allEvents = await googleCalendarService.getUpcomingEvents(context.userId, 100);
      events = allEvents.filter(event => {
        if (!event.start?.dateTime) return false;
        const eventTime = new Date(event.start.dateTime);
        const eventTime = getEventStartInstant(event);
        if (!eventTime) return false;
        return eventTime >= startTime && eventTime <= endTime;
      });
    } else {
      // Default: get recent and upcoming events
      events = await googleCalendarService.getUpcomingEvents(context.userId, 10);
    }
    
    // Transform to standardized format
    const transformedEvents: CalendarEvent[] = events.map(event => ({
      id: event.id,
      summary: event.summary || 'No Title',
      start: event.start,
      end: event.end,
      attendees: params.includeAttendees ? event.attendees?.map((attendee: any) => ({
        email: attendee.email,
        displayName: attendee.displayName,
        responseStatus: attendee.responseStatus
      })) : undefined,
      description: event.description,
      location: event.location
    }));
    
    console.log(`[MCP-Calendar] Found ${transformedEvents.length} events for ${params.eventId || params.contactEmail || 'time range'}`);
    
    return {
@@ -95,52 +113,52 @@ export async function calendarAttendeeHistory(
): Promise<{ events: CalendarEvent[]; attendeeEmail: string; lookbackDays: number }> {
  try {
    const params = calendarAttendeeHistorySchema.parse(args);
    
    // Import the Google Calendar service dynamically
    const { googleCalendarService } = await import('../../services/googleCalendar.js');
    
    // Calculate the date range for lookback
    const now = new Date();
    const lookbackDate = new Date(now.getTime() - (params.lookbackDays * 24 * 60 * 60 * 1000));
    
    // Get events from the lookback period (we'll need to implement a date range method)
    // For now, we'll get recent events and filter
    const allEvents = await googleCalendarService.getUpcomingEvents(context.userId, 200);
    
    // Filter for events with the specific attendee and within date range
    const matchingEvents = allEvents.filter(event => {
      // Check if event has the attendee
      const hasAttendee = event.attendees?.some((attendee: any) => 
        attendee.email === params.attendeeEmail
      );
      
      if (!hasAttendee) return false;
      
      // Check if event is within date range
      if (!event.start?.dateTime) return false;
      const eventDate = new Date(event.start.dateTime);
      const eventDate = getEventStartInstant(event);
      if (!eventDate) return false;
      return eventDate >= lookbackDate && eventDate <= now;
    }).slice(0, params.maxResults);
    
    // Transform to standardized format
    const transformedEvents: CalendarEvent[] = matchingEvents.map(event => ({
      id: event.id,
      summary: event.summary || 'No Title',
      start: event.start,
      end: event.end,
      attendees: event.attendees?.map((attendee: any) => ({
        email: attendee.email,
        displayName: attendee.displayName,
        responseStatus: attendee.responseStatus
      })),
      description: event.description,
      location: event.location
    }));
    
    console.log(`[MCP-Calendar] Found ${transformedEvents.length} historical events with ${params.attendeeEmail} in last ${params.lookbackDays} days`);
    
    return {
      events: transformedEvents,
      attendeeEmail: params.attendeeEmail,
      lookbackDays: params.lookbackDays
    };